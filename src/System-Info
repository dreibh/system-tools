#!/usr/bin/env bash
#
# System-Info
# Copyright (C) 2013-2023 by Thomas Dreibholz
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Contact: dreibh@simula.no


# ###### Print banners ######################################################
function print-banners ()
{
   for directory in /etc/system-info.d /usr/local/etc/system-info.d ; do
      if [ -d ${directory} ] ; then
         bannerScripts=`find ${directory} -maxdepth 1 -type f -name "[0-9][0-9]*[^~]" | sort -r`
         for bannerScript in ${bannerScripts} ; do
            ${bannerScript} || break
         done
      fi
   done
}


# ###### Print system information ###########################################
function print-system-information ()
{
   # ====== Obtain host information =========================================
   hostnameResult=`hostname -f`
   uptimeResult=`env LANGUAGE=en uptime`
   cpu=`uname -m`
   kernel=`uname -r`

   # ====== Obtain CPU information ==========================================
   cores=$(grep -c ^processor /proc/cpuinfo 2>/dev/null || grep -c ^processor /compat/linux/proc/cpuinfo 2>/dev/null || echo "1" )
   [ "$cores" -eq "0" ] && cores=1
   systemLoad=`echo "${uptimeResult}" | awk -F 'average[s]*:' '{ gsub(/^[ ]*/, "", $2); print $2 }'`

   if $(echo "${uptimeResult}" | grep -E "min|days" >/dev/null); then
      uptime=`echo "${uptimeResult}" | awk '{ print $3 " "$4 }' | sed 's/,//g'`
   else
      uptime=`echo "${uptimeResult}" | awk '{ print $3 " hours" }' | sed 's/,//g'`
   fi
   processes=`ps axue | grep -vE "^USER|grep|ps" | wc -l`

   # ====== Obtain user information =========================================
   users=`who | awk ' { print $1 }' | sort -ud | wc -l`

   # ====== Obtain disk information =========================================
   diskRoot=`env LANGUAGE=en df -hT /     | grep -vE "^Filesystem|shm" | awk '{ print $6 }'`
   diskHome=`env LANGUAGE=en df -hT /home | grep -vE "^Filesystem|shm" | awk '{ print $6 }'`

   # ====== Obtain operating system and memory information ==================
   DISTRIB_ID="Unknown"
   DISTRIB_RELEASE="00.00"
   DISTRIB_CODENAME="unknown"
   if [ "${system}" == "Linux" ] ; then
      if [ -e /etc/lsb-release ] ; then
         . /etc/lsb-release
      elif [ -x /usr/bin/lsb_release ] ; then
         DISTRIB_ID=`/usr/bin/lsb_release -is`
         DISTRIB_RELEASE=`/usr/bin/lsb_release -rs`
         DISTRIB_CODENAME=`/usr/bin/lsb_release -cs`
      elif [ -e /etc/fedora-release ] ; then
         DISTRIB_ID=`cat /etc/fedora-release | sed -e "s/^\(.*\) release \([0-9]*\) (\(.*\))$/\1/g"`
         DISTRIB_RELEASE=`cat /etc/fedora-release | sed -e "s/^\(.*\) release \([0-9]*\) (\(.*\))$/\2/g"`
         DISTRIB_CODENAME=`cat /etc/fedora-release | sed -e "s/^\(.*\) release \([0-9]*\) (\(.*\))$/\3/g"`
      fi

      freeOutput="`env LANGUAGE=en free -mt`"
      freeMemOutput="`echo "${freeOutput}" | grep "^Mem:"`"
      freeSwapOutput="`echo "${freeOutput}" | grep "^Swap:"`"

      let memoryUsed=`echo "${freeMemOutput}" | awk '{ print $3 }'`
      let memoryFree=`echo "${freeMemOutput}" | awk '{ print $4 }' `
      let memoryTotal=`echo "${freeMemOutput}" | awk '{ print $2 }'`
      let swapUsed=`echo "${freeSwapOutput}" | awk '{ print $3 }'`
      let swapFree=`echo "${freeSwapOutput}" | awk '{ print $4 }'`
      let swapTotal=`echo "${freeSwapOutput}" | awk '{ print $2 }'`
   elif  [ "${system}" == "FreeBSD" ] ; then
      DISTRIB_ID="FreeBSD"
      DISTRIB_RELEASE="`echo "$kernel" | sed -e "s/-[A-Z].*//g"`"
      DISTRIB_CODENAME=""

      pageSize=`sysctl -n hw.pagesize`
      let vmstatActive=`sysctl -n vm.stats.vm.v_active_count`*${pageSize}
      let vmstatInactive=`sysctl -n vm.stats.vm.v_inactive_count`*${pageSize}
      let vmstatCache=`sysctl -n vm.stats.vm.v_cache_count`*${pageSize}
      let vmstatFree=`sysctl -n vm.stats.vm.v_free_count`*${pageSize}

      let memoryFree=(${vmstatInactive}+${vmstatCache}+${vmstatFree})/1048576
      let memoryTotal=`sysctl -n hw.physmem`/1048576
      let memoryUsed=${memoryTotal}-${memoryFree}

      let swapTotal=`sysctl -n vm.swap_total`/1048576
      let swapUsed=`sysctl -n vm.swap_reserved`/1048576
      let swapFree=${swapTotal}-${swapUsed}
   fi

   # ====== Print system information ========================================
   echo -en "\x1b[33m"
   if [ -e /etc/slicename -a /etc/slicefamily ] ; then
      echo -e "Slice:            `cat /etc/slicename` (`cat /etc/slicefamily`)"
   fi
   echo "Host:             ${hostnameResult}"
   echo "Uptime:           ${uptime}"
   codeNameText=""
   if [ "${DISTRIB_CODENAME}" != "" ] ; then
      codeNameText=" (${DISTRIB_CODENAME})"
   fi
   echo "System:           ${DISTRIB_ID} ${DISTRIB_RELEASE}${codeNameText} with kernel ${kernel}"
   printf "Processor:        %d Ã— ${cpu}; %d processes; %d users\n" "${cores}" "${processes}" "${users}"
   echo "Load:             ${systemLoad}"
   printf "Used Memory:      %5d MiB of %5d MiB (%5d MiB free)\n" ${memoryUsed} ${memoryTotal} ${memoryFree}
   printf "Used Swap:        %5d MiB of %5d MiB (%5d MiB free)\n" ${swapUsed} ${swapTotal} ${swapFree}
   echo "Used Diskspace:   ${diskRoot} on /, ${diskHome} on /home"
}


# ###### Print SSH public key fingerprints ##################################
function print-ssh-key-fingerprints ()
{
   keys=`find /etc/ssh -maxdepth 1 -name "ssh_host_*.pub" | sort`
   firstKey=1
   for key in $keys ; do
      if [ ${firstKey} -eq 1 ] ; then
         echo -n "SSH Keys:         "
         firstKey=0
      else
         echo -n "                  "
      fi
      ssh-keygen -lf $key | sed -e "s/^\([0-9]*\) \([^ ]*\) \(.*\) (\(.*\))$/\2 (\4 \1)/g"
   done
}


# ###### Convert FreeBSD hexadecimal netmask to prefix length ###############
function hex-netmask-to-prefixlen ()
{
   local N=$(($1))
   local prefixlen=0
   local i=31
   while [ $i -ge 0 ] ; do
      local b=$((1<<i))
      if [ $(($N & $b)) -ne 0 ] ; then
         let prefixlen=${prefixlen}+1
      else
         break
      fi
      let i=$i-1
   done
   echo "${prefixlen}"
}


# ###### Print addresses ####################################################
function showAddresses ()
{
   lastInterface=""
   hasIPv4=0
   while read interface up protocol address prefixlen ; do
      # ====== Get interface status =========================================
      if [ "${up}" == "1" ] ; then
         # Interface is UP
         colorA="\x1b[34m"
         colorP="\x1b[94m"
      else
         # Interface is DOWN
         colorA="\x1b[37m"
         colorP="\x1b[37m"
      fi
      echo -en "${colorA}"

      # ====== Print addresses ==============================================
      if [ "${lastInterface}" != "${interface}" ] ; then
         if [ "${lastInterface}" != "" ] ; then
            echo ""
         fi
         lastInterface="${interface}"
         hasIPv4=0
         printf "   %-14s " "${interface}:"
      fi

      if [ "${protocol}" == "4" ] ; then
         echo -en "${address} ${colorP}/ ${prefixlen}${colorA}   "
         hasIPv4=1
      elif [ "${protocol}" == "6" ] ; then
         if [ ${hasIPv4} -eq 0 ] ; then
            echo -n "(No IPv4)"
         fi
         echo -en "\n                  ${address} ${colorP}/ ${prefixlen}${colorA} "
      fi
      echo -en "\x1b[0m"
   done <<< "$1"
   echo ""
}


# ###### Print network addresses of each interface ##########################
function print-network-addresses ()
{
   # ====== Get Linux network configuration =================================
   if [ "${system}" == "Linux" ] ; then
      read -r -a allTunnelInterfaces <<< "`(ip -4 tunnel show ; ip -6 tunnel show ) | cut -d':' -f1 | sort -u | xargs`"
      addressList=`ip addr show | (
         interface="BAD!"
         hidden=1
         up=0
         while read line ; do
            # ------ Interface name and flags -------------------------------
            if [[ "${line}" =~ ^([0-9]+)(: )([a-zA-Z0-9\.-]+)(@[a-zA-Z0-9\.-]+|)(: <)([^>]*)(>) ]] ; then
               interface="${BASH_REMATCH[3]}"
               flags=(${BASH_REMATCH[6]//,/ })
               if [[ " ${flags[@]} " =~ UP ]] ; then
                  up=1
               else
                  up=0
               fi
               if [[ " ${flags[@]} " =~ LOOPBACK ]] ; then
                  hidden=1
               elif [[ " ${allTunnelInterfaces[@]} " =~ ${interface} ]] ; then
                  hidden=1
               else
                  hidden=0
               fi
            elif [ ${hidden} -eq 0 ] ; then
               # ------ IPv4 ------------------------------------------------
               if [[ "${line}" =~ ^(inet )([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})\/([0-9]{1,2}) ]] ; then
                  echo -e "${interface}\t${up}\t4\t${BASH_REMATCH[2]}\t${BASH_REMATCH[3]}"
               # ------ IPv6 ---------------------------------------------------
               elif [[ "${line}" =~ ^(inet6 )([0-9a-f:]+)\/([0-9]{1,3})( scope [gsh]) ]] ; then
                  # This already filters out link local by scope!
                  echo -e "${interface}\t${up}\t6\t${BASH_REMATCH[2]}\t${BASH_REMATCH[3]}"
               fi
               # ------ Not relevant -------------------------------------------
               # else
               #    echo "no match: ${line}"
            fi
         done
      ) | sort -k1,2`

   # ====== Get FreeBSD network configuration ===============================
   else
      addressList=`ifconfig | (
         interface="BAD!"
         hidden=1
         up=0
         while read line ; do
            # ------ Interface name and flags -------------------------------
            if [[ "${line}" =~ ^([a-zA-Z0-9\.-]+)(@[a-zA-Z0-9\.-]+|())(: flags=[0-9]+<)([^>]*)(>) ]] ; then
               interface="${BASH_REMATCH[1]}"
               flags=(${BASH_REMATCH[5]//,/ })
               if [[ " ${flags[@]} " =~ UP ]] ; then
                  up=1
               else
                  up=0
               fi
               if [[ " ${flags[@]} " =~ LOOPBACK ]] ; then
                  hidden=1
               elif [[ " ${allTunnelInterfaces[@]} " =~ ${interface} ]] ; then
                  hidden=1
               else
                  hidden=0
               fi
            elif [ ${hidden} -eq 0 ] ; then
               # ------ IPv4 ------------------------------------------------
               if [[ "${line}" =~ ^(inet )([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})( netmask )(0x[0-9a-f]{8}) ]] ; then
                  netmask=$(hex-netmask-to-prefixlen "${BASH_REMATCH[4]}")
                  echo -e "${interface}\t${up}\t4\t${BASH_REMATCH[2]}\t${netmask}"
               # ------ IPv6 ------------------------------------------------
               elif [[ "${line}" =~ ^(inet6 )([0-9a-f:]+)( prefixlen )([0-9]{1,3}) ]] ; then
                  # This already filters out link local: fe80:...%<interface>!
                  echo -e "${interface}\t${up}\t6\t${BASH_REMATCH[2]}\t${BASH_REMATCH[4]}"
               # ------ Not relevant ----------------------------------------
               # else
               #    echo "no match: ${line}"
               fi
            fi
         done
      ) | sort -k1,2`

   fi

   # ====== Print network information =======================================
   echo "Network:"
   showAddresses "${addressList}"
}



# ###### Main program #######################################################
echo ""
echo "System information as of `env LANGUAGE=en date`"
echo ""

system=`uname`

# Getting the network information may take a few hundreds of ms on a router
# => prepare it in background, while printing other information.
networkInfo=`mktemp`
print-network-addresses >${networkInfo} &

print-banners
print-system-information
print-ssh-key-fingerprints
wait
cat ${networkInfo} && rm -f ${networkInfo}
